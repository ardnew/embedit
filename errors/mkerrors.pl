use strict;
use warnings;

die "error: required env variable(s) undefined: @_\n"
  if (@_ = grep { not exists $ENV{$_} } qw| GOFILE GOLINE GOPACKAGE |);

# Parse desired list of errors from existing source file.
my @error;
open my $src, "<", $ENV{GOFILE} or die "error: ${ENV{GOFILE}}: $!\n";
while (<$src>) {
  chomp;
  if ($. > $ENV{GOLINE}) {
    last unless m{^//};
    push @error, m{(?://|\s+)(\S+)}g
  }
}
close $src;

# Build the Go source.
my @out = (
  "// Code generated by ${0}. DO NOT EDIT.", "",
  "package ${ENV{GOPACKAGE}}", "",
  ( map { s|[\r\n]||; $_ } sprintf ('//go:generate %s', qx[ ps -o args= $$ ]) ),
  ( map { "// ${_}" } @error ), "",
  "type (", ( map { "\t${_} string"} @error ), ")", "",
  "var (", ( map { "\tErr${_} ${_}"} @error ), ")", "",
);
for (@error) {
  # Split identifier in error string into space-separated, lowercase words.
  #   (Identifier may be CamelCase, Under_score1, or a Mixture_of_TheTwo, which
  #    would appear as: "camel case", "under score 1", "mixture of the two")
  @_ = map { lc } m/_*((?:[A-Z0-9]|(?<=_)[A-Za-z0-9])[a-z]*)/g;
  push @out,
    qq`func (e *${_}) Error() string {`,
    qq`	return "@{_}: + string(*e)"`,
    qq`}`, "";
}

# Write the Go source to file.
open $src, ">", $ENV{GOFILE} or die "error: ${ENV{GOFILE}}: $!\n";
{
  local $" = "\n";
  print $src "@out\n";
}
close $src;

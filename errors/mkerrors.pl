use strict;
use warnings;

# Define the type of all generated error types.
my $type = "struct{}";

# Define the Error method implementation of each error type.
# Evaluated in list context. Each value returned is its own line.
sub func {
  my ($error) = @_;
  # Split identifier in error string into space-separated, lowercase words.
  #   (Identifier may be CamelCase, Under_score1, or a Mixture_of_TheTwo, which
  #    would appear as: "camel case", "under score 1", "mixture of the two")
  @_ = map { lc } ($error =~ m{_*((?:[A-Z0-9]|(?<=_)[A-Za-z0-9])[a-z]*)}g);
<<______________________________________________________________________________
func (e *${error}) Error() string {
	return "@{_}"
}
______________________________________________________________________________
}

die "error: required env variable(s) undefined: @_\n"
  if (@_ = grep { not exists $ENV{$_} } qw| GOFILE GOLINE GOPACKAGE |);

# Parse desired list of errors from existing source file.
my @error;
open my $src, "<", $ENV{GOFILE} or die "error: ${ENV{GOFILE}}: $!\n";
while (<$src>) {
  chomp;
  if ($. > $ENV{GOLINE}) {
    last unless m{^//};
    push @error, m{(?://|\s+)(\S+)}g
  }
}
close $src;

# Build the Go source.
my @out = (
  "// Code generated by ${0}. DO NOT EDIT.",
  "",
  "package ${ENV{GOPACKAGE}}",
  "",
  ( map { s/[\r\n]//; $_ } sprintf ('//go:generate %s', qx[ ps -o args= $$ ]) ),
  ( map { "// ${_}" } @error ),
  "",
  "type (", ( map { "\t${_} ${type}"} @error ), ")",
  "",
  "var (", ( map { "\tErr${_} ${_}"} @error ), ")",
  "",
  ( map { func($_) } @error ),
);

# Write the Go source to file.
open $src, ">", $ENV{GOFILE} or die "error: ${ENV{GOFILE}}: $!\n";
{
  local $" = "\n";
  print $src "@out";
}
close $src;

exec { "gofmt" } qw{ gofmt -w -s }, $ENV{GOFILE}
